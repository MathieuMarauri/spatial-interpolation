---
title: "Spatial interpolation"
output:
  html_document:
    code_folding: show
    toc: true
    toc_depth: 2
    theme: cerulean
    highlight: tango
    css: style.css
bibliography: biblio.bib
biblio-style: "apalike"
link-citations: true
---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { 
      equationNumbers: {
 
            autoNumber: "all",
      } 
  }
});
</script>

<!-- https://groups.google.com/forum/#!topic/knitr/OMvT03PtGPM --> 

```{r initial_chunk, echo = FALSE, warning = FALSE, message = FALSE}
library("knitr")
opts_chunk$set(echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE, vcache = FALSE, fig.align = 'center', dpi = 300, out.width = '75%')
```

```{r set-up}
import::from("fields", "rdist") # rdist function
library("ggplot2") # data visualisation
library("magrittr") # pipe operators
library("tidyr") # pivot tables

# Set default ggplot theme
theme_set(
  theme_light(
  base_size = 20
  ) +
  theme(
    text = element_text(family = "Gibson", colour = "gray10"),
    panel.border = element_blank(),
    axis.line = element_line(colour = "gray50", size = .5),
    axis.ticks = element_blank(),
    strip.background = element_rect(colour = "gray50", fill = "transparent", size = .7),
    strip.text.x = element_text(colour = "gray10"),
    strip.text.y = element_text(colour = "gray10"),
    legend.key.size = unit(1.5, "cm")
  )
)

# Set default scales
scale_colour_continuous <- function(...) ggplot2::scale_colour_viridis_c(..., option = "viridis")
scale_colour_discrete <- function(...) ggplot2::scale_colour_viridis_d(..., option = "viridis")
scale_fill_continuous <- function(...) ggplot2::scale_fill_viridis_c(..., option = "viridis")
scale_fill_discrete <- function(...) ggplot2::scale_fill_viridis_d(..., option = "viridis")
```


TODO : Introduction

#### The mathematical problem

Let's say you have $n$ measures $z_1, \dots, z_n$ of some variable $Z$ at $n$ points in some region of space $R \subset \in \mathbb{R}^2$. You want to know the value of $Z$ at every points in that region $R$. You have to define a function that for each point $(x, y) \in R$ associates a value $z \in \mathbb{R}$.

$$
(x, y) \in \mathbb{R}^2 \rightarrow z \in \mathbb{R}
$$

The only input data as your disposal are $n$ estimations of $f$ at sample points $s_1, \dots , s_n$, $s_i \in \mathbb{R}^2, i = 1 \dots n$. 

Different methods exists [see @overview] and most have the same general formula. The prediction $\widehat{z_0}$ for a point $s_0 \in \mathbb{R}^2$ is given by the following relation:

$$
\widehat{z_0} = \sum_{i = 1}^{n}\lambda_i z_i
$$

The way the weights $\lambda_1, \dots , \lambda_n$ is different for each methods. 4 methods are presented in this document: 

* Inverse Distance Weighting (IDW), 
* Triangular Irregular Networks (TIN), 
* Gaussian Process (GP)
* Kriging

#### A simple map as a case study

To illustrate the different methods we will use a simple use case, a simulated normal variable, $Z$, on a $[0, 100] \times [0, 100]$ grid. A random sample of 100 points are selected and will be used as the basis for the spatial interpolation. 

```{r grid}
simulated_grid <- read.table("../data/simulation.txt", header = TRUE)
set.seed(123)
sample_points <- simulated_grid[sample(1:10201, 100), ]
ggplot(
  data = simulated_grid,
  mapping = aes(x = x, y = y, fill = z)
) +
  geom_tile() +
  geom_point(
    data = sample_points,
    mapping = aes(x = x, y = y)
  ) + 
  guides(
    fill = guide_colorbar(title.vjust = 0.8)
  ) +
  labs(
    title = "The 100 sample points on the true map"
  ) +
  theme_void() +
  theme(
    legend.position = 'bottom'
  )
```

Having true data will make it possible to compare the solution to the real data and to evaluate its performance. Of course in a real life scenario you do not have the real data, hence for each method, a more challenging use case will also be presented. 

# Inverse Distance Weighting

## How it works

This methods uses the previous equation to predict new values. The weights $\lambda_1, \dots , \lambda_n$ are defined by taking the inverse of the distance between the point to predict, $s_0$, and the sample points, at a pecific power $p$. This method directly considers that the closer a point is to another the more alike they are. For $s_0$, $\forall i = 1\dots n$ and $p \in \mathbb{N}$,

$$
\lambda_i = \frac{\left(dist(s_0, s_j)^p\right)^{-1}}{\left(\sum_{j=1}^{n}dist(s_0, s_j)^p\right)^{-1}}
$$

The distance used is usually the euclidean distance $dist(a, b) = ||a-b||^2$. The parameter $p$ define the rate at which the influence of a point to another decreases. The higher $p$ the fastest the decrease of influence.

```{r power}
x_seq <- seq(0, 10, length.out = 11)
ggplot(
  data = data.frame(
    x = rep(x_seq, 5),
    y = c(1 / x_seq^0, 1 / x_seq^1, 1 / x_seq^2, 1 / x_seq^3, 1 / x_seq^4),
    color = rep(as.character(0:4), each = 11)
  ), 
  mapping = aes(x = x, y = y, color = color)
) + 
  geom_line()
```

## The simple case study

First let's apply IDW on our simple sample points. Recall we have 100 points and we want to predict the value of the variable of interest $Z$ for every point of the grid $[0, 100] \times [0, 100]$.

Building the interpolated map means making a prediction for each point in the grid. What we have to do is then to compute the distance matrix between each point and the sample points, use these distances to build the weights and build our prediction according to equation 2 $\widehat{z_0} = \sum_{i = 1}^{n}\lambda_i z_i$. 

```{r idw, echo = TRUE}
# First compute the distance matrix between all points of the grid and all sample points
distance <- rdist(simulated_grid[, c("x", "y")], sample_points[, c("x", "y")])

# Take the inverse of every element
weights <- apply(
  X = distance, 
  MARGIN = 1:2,
  FUN = function(x) 1 / x
)

# Substract (FUN = "-") row sums (STATS = row_sums) to every element of the weights matrix (x = weights) row wise (MARGIN = 1)
weights <- sweep(
  x = weights, 
  MARGIN = 1, 
  STATS = 1 / rowSums(distance), 
  FUN = "-"
) 

# Multiply the weights matrix with the z value of the sample points
pred <- weights %*% sample_points$z
```

We can now visualize our final prediction and compare it to the real data.

```{r idw_pred_map}
cbind(simulated_grid[, c("x", "y")], Precition = pred, "Real data" = simulated_grid$z) %>%
  pivot_longer(cols = Precition:`Real data`, names_to = "type", values_to = "Z") %>%
  ggplot(
    mapping = aes(x = x, y = y, fill = Z)
  ) +
  geom_tile() +
  geom_tile(
    data = sample_points,
    mapping = aes(x = x, y = y),
    fill = "black"
  ) +
  guides(
    fill = guide_colorbar(title.vjust = 0.8)
  ) +
  facet_grid(cols = vars(type)) +
  labs(
    title = "Prediction with IDW and real data"
  ) +
  scale_x_continuous(
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    expand = c(0, 0)
  ) +
  theme_void() +
  theme(
    legend.position = 'bottom',
    strip.text = element_text(size = 12)
  )
```



# Help

$$
\begin{equation} 
\begin{split}
\mathrm{Var}(\hat{\beta}) & =\mathrm{Var}((X'X)^{-1}X'y)\\
 & =(X'X)^{-1}X'\mathrm{Var}(y)((X'X)^{-1}X')'\\
 & =(X'X)^{-1}X'\mathrm{Var}(y)X(X'X)^{-1}\\
 & =(X'X)^{-1}X'\sigma^{2}IX(X'X)^{-1}\\
 & =(X'X)^{-1}\sigma^{2}
\end{split}
\end{equation} 
$$

# References